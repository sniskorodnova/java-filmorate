# java-filmorate
В данном проекте реализовано приложение Filmorate на Spring Boot.

В приложении есть возможность создавать, редактировать пользователей, а также получать список всех пользователей.
Также есть возможность создавать, редактировать фильмы, а также получать список всех фильмов. Пользователь может
поставить лайк фильму, а также удалить лайк у фильма. Можно добавить пользователя в друзья (данная операция
автоматически взаимная), удалить из друзей, а также получить список общих друзей двух пользователей и топ фильмов
по количеству лайков.

Взаимодействие с приложением происходит по API.  
Методы для работы с пользователями:  
POST /users - создание пользователя  
PUT /users - редактирование пользователя  
GET /users - получение списка всех пользователей  
GET /users/{userId} - получение информации о пользователе по его id  
PUT /users/{userId}/friends/{friendId} - добавление пользователя в друзья другому пользователю  
DELETE /users/{userId}/friends/{friendId} - удаление пользователя из друзей другого пользователя  
GET /users/{userId}/friends - получение списка друзей пользователя  
GET /users/{userId}/friends/common/{otherUserId} - получение списка общих друзей двух пользователей  


Методы для работы с фильмами:  
POST /films - создание фильма  
PUT /films - редактирование фильма  
GET /films - получение списка всех фильмов  
GET /films/{filmId} - получение информации о фильме по его id  
PUT /films/{filmId}/like/{userId} - проставление лайку фильму пользователем  
DELETE /films/{filmId}/like/{userId} - удаление лайка у фильма пользователем  
GET /films/popular - получение топа самых популярных фильмов по количеству лайков (если у двух фильмов одинаковое
количество лайков, то они сортируются по имени)


Для создания и редактирования пользователя добавлены валидационные правила:
- электронная почта не может быть пустой и должна содержать символ @
- логин не может быть пустым и содержать пробелы
- имя для отображения может быть пустым (в таком случае будет использован логин)
- дата рождения не может быть в будущем

Для создания и редактирования фильма добавлены валидационные правила:
- название не может быть пустым
- максимальная длина описание - 200 символов
- дата релиза - не раньше 29 декабря 1895 года
- продолжительность фильма должна быть положительной

В приложении добавлено логирование запросов, а также логирование исключений при некорректных входящих данных.

![DB Schema](./QuickDBD-Filmorate.png)

Одному фильму соответствует один рейтинг. Также каждому фильму может соответствовать один или несколько жанров. Жанры
и фильмы связаны через таблицу film_genre.
Лайки пользователей для фильмов связаны через таблицу user_film_likes.
Таблица friendship_suggestion содержит записи о пользователях, которые отправили запрос на добавление в друзья.
Таблица friendship содержит записи о пользователях, которые дружат друг с другом.
Если user1 делает запрос на добавление в друзья для user2 и в таблицах friendship_suggestion и friendship
нет записей [[id], user1, user2] или [[id], user2, user1], то делаем новую запись в таблице friendship_suggestion.
Если какая-либо из этих записей есть в какой-либо из таблиц friendship_suggestion и friendship, то запись не добавляем.
Если user2 делает запрос в друзья для user1 - проверяем по таблице friendship_suggestion есть ли запись
[[id], user1, user2]. Если такая есть - то удаляем ее из таблицы, а в таблицу friendship добавляем новую запись
[[id], user1, user2].

Примеры запросов для выборки данных:  
1. Получить все фильмы  
```
SELECT name  
FROM film;  
```

2. Получить список первых N фильмов по количеству лайков  
```
SELECT f.film_id, f.film_name, COUNT(u.user_id) AS likes_count  
FROM film f  
LEFT OUTER JOIN user_film_likes u ON f.film_id = u.film_id  
GROUP BY f.film_id  
ORDER BY likes_count DESC  
LIMIT N;  
```

3. Получить всех пользователей  
```
SELECT name  
FROM user;  
```

4. Получить список друзей пользователя "пользователь_id"  
```
SELECT u.name  
FROM (SELECT user1_id AS user_id  
      FROM friendship  
      WHERE user2_id = [пользователь_id]  
      UNION ALL  
      SELECT user2_id AS user_id  
      FROM friendship  
      WHERE user1_id = [пользователь_id]) AS users_id  
INNER JOIN user u ON u.user_id = users_id.user_id;  
```

5. Получить список общих друзей двух пользователей [пользователь1_id] и [пользователь2_id]
```
SELECT u.name  
FROM ((SELECT user1_id AS user_id  
      FROM friendship  
      WHERE user2_id = [пользователь1_id]  
      UNION ALL  
      SELECT user2_id AS user_id  
      FROM friendship  
      WHERE user1_id = [пользователь1_id]) AS user1_friends)  
      INTERSECT  
      (SELECT user1_id AS user_id  
      FROM friendship  
      WHERE user2_id = [пользователь2_id]  
      UNION ALL  
      SELECT user2_id AS user_id  
      FROM friendship  
      WHERE user1_id = [пользователь2_id]) AS user2_friends)) AS common_friends  
INNER JOIN user u ON u.user_id = common_users.user_id;
```  